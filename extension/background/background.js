/**
 * VynceAI Extension - Background Service Worker
 * Handles API communication and message routing between popup and content scripts
 */

// Import the API module using importScripts or dynamic import
// Since we can't use top-level import in service workers without "type": "module"
// We'll use dynamic import inside an async context

// Configuration
const API_BASE_URL = 'http://127.0.0.1:8000';
const API_ENDPOINTS = {
  chat: '/api/v1/ai/chat',
  query: '/api/v1/ai/query',
  models: '/api/v1/ai/models',
  health: '/api/v1/utils/health'
};

console.log('VynceAI Background Service Worker initializing...');

// Test backend connection on startup
checkBackendConnection();

async function checkBackendConnection() {
  try {
    const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.health}`);
    if (response.ok) {
      console.log('‚úÖ Backend connected successfully');
    } else {
      console.warn('‚ö†Ô∏è Backend returned error:', response.status);
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è Backend not reachable. Using mock responses.');
  }
}

/**
 * Call the real FastAPI backend
 */
async function callBackend(model, prompt, context = null, memory = null) {
  try {
    console.log('Calling backend API:', { model, prompt: prompt.substring(0, 50) + '...' });
    
    const payload = {
      model: model,
      prompt: prompt
    };
    
    // Add context if available
    if (context) {
      payload.context = {
        url: context.url,
        title: context.title,
        selectedText: context.selectedText,
        pageContent: context.textContent
      };
    }
    
    // Add memory if available
    if (memory && memory.length > 0) {
      payload.memory = memory;
    }
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 second timeout
    
    try {
      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.chat}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload),
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`API error: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log('‚úÖ Backend response received');
      
      return {
        text: data.response || data.message || data.text,
        model: data.model || model,
        tokens: data.tokens || 0,
        success: true,
        source: 'backend'
      };
      
    } catch (fetchError) {
      clearTimeout(timeoutId);
      
      if (fetchError.name === 'AbortError') {
        console.warn('‚è±Ô∏è Request timeout. Using mock response.');
      } else {
        console.warn('‚ùå Backend request failed:', fetchError.message);
      }
      
      // Fallback to mock
      return getMockResponse(model, prompt);
    }
    
  } catch (error) {
    console.error('üí• API call failed:', error);
    return getMockResponse(model, prompt);
  }
}

function getMockResponse(model, prompt) {
  console.log('üìù Using mock response for:', model);
  
  return new Promise((resolve) => {
    setTimeout(() => {
      const responses = {
        'gemini-2.5-flash': `üöÄ **VynceAI Response** (Gemini 2.5 Flash)\n\nI understand you're asking about "${prompt.substring(0, 50)}..."\n\nHere's my analysis:\n\n‚ú® **Key Points:**\n‚Ä¢ This is an intelligent response\n‚Ä¢ Generated by your local backend\n‚Ä¢ Connect your backend at http://127.0.0.1:8000\n\nüí° **Note:** This is a demo response. Start your FastAPI backend to get real AI responses!`,
        'gemini-1.5-flash': `Quick response to "${prompt}"!\n\n‚ö° **Fast Analysis:**\n- Key insight #1\n- Key insight #2\n- Key insight #3\n\nNeed more details?`,
        'gemini-2.5-pro': `Comprehensive analysis of "${prompt}":\n\nüéØ **Deep Dive:**\n1. Contextual understanding\n2. Multiple perspectives\n3. Detailed recommendations\n\nHow can I help further?`
      };
      
      resolve({
        text: responses[model] || `VynceAI response from ${model}: I received your message "${prompt}". This is a demo response. The server is now connected!`,
        model,
        tokens: Math.floor(Math.random() * 500) + 100,
        success: true,
        mock: true
      });
    }, 1000 + Math.random() * 1000);
  });
}

// Extension installation/update handler
chrome.runtime.onInstalled.addListener((details) => {
  if (details.reason === 'install') {
    console.log('VynceAI Extension installed successfully!');
    
    // Set default settings
    chrome.storage.local.set({
      selectedModel: 'gemini-2.5-flash',
      conversationHistory: [],
      settings: {
        autoContext: true,
        darkMode: true,
        apiKey: null
      }
    });
    
    // Open welcome page (optional)
    // chrome.tabs.create({ url: 'https://vynceai.com/welcome' });
  } else if (details.reason === 'update') {
    console.log('VynceAI Extension updated to version:', chrome.runtime.getManifest().version);
  }
});

// Listen for messages from popup and content scripts
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log('Background received message:', request.type);
  
  switch (request.type) {
    case 'SEND_PROMPT':
      handleSendPrompt(request.payload, sendResponse);
      return true; // Keep channel open for async response
      
    case 'EXECUTE_COMMAND':
      handleExecuteCommand(request.payload, sendResponse);
      return true;
      
    case 'GET_TAB_INFO':
      handleGetTabInfo(sender, sendResponse);
      return true;
      
    case 'EXECUTE_ACTION':
      handleExecuteAction(request.payload, sendResponse);
      return true;
      
    case 'SAVE_SETTINGS':
      handleSaveSettings(request.payload, sendResponse);
      return true;
      
    case 'GET_AVAILABLE_MODELS':
      handleGetAvailableModels(sendResponse);
      return true;
      
    default:
      console.warn('Unknown message type:', request.type);
      sendResponse({ success: false, error: 'Unknown message type' });
  }
});

/**
 * Handle sending prompt to AI backend
 */
async function handleSendPrompt(payload, sendResponse) {
  const { model, prompt, context, memory } = payload;
  
  try {
    console.log(`Sending prompt to ${model}:`, prompt);
    
    // Call backend API with memory
    const response = await callBackend(model, prompt, context, memory);
    
    console.log('AI Response received:', response);
    
    sendResponse({
      success: true,
      data: {
        response: response.text,
        model: response.model,
        tokens: response.tokens,
        timestamp: Date.now()
      }
    });
    
  } catch (error) {
    console.error('Error in handleSendPrompt:', error);
    
    sendResponse({
      success: false,
      error: error.message || 'Failed to get AI response'
    });
  }
}

/**
 * Get available models from backend
 */
async function handleGetAvailableModels(sendResponse) {
  try {
    console.log('Fetching available models from backend...');
    
    const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.models}`);
    
    if (!response.ok) {
      throw new Error(`API error: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('‚úÖ Available models fetched:', data);
    
    sendResponse({
      success: true,
      models: data.models || []
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching models:', error);
    
    // Return fallback models based on what's typically configured
    sendResponse({
      success: false,
      error: error.message,
      models: [
        // Gemini models (VynceAI uses Gemini only)
        { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash', provider: 'gemini' },
        { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro', provider: 'gemini' },
        { id: 'gemini-flash-latest', name: 'Gemini Flash Latest', provider: 'gemini' }
      ]
    });
  }
}

/**
 * Get information about the current tab
 */
async function handleGetTabInfo(sender, sendResponse) {
  try {
    const tab = sender.tab;
    
    if (!tab) {
      throw new Error('No active tab found');
    }
    
    sendResponse({
      success: true,
      data: {
        url: tab.url,
        title: tab.title,
        favIconUrl: tab.favIconUrl,
        id: tab.id
      }
    });
    
  } catch (error) {
    console.error('Error getting tab info:', error);
    sendResponse({
      success: false,
      error: error.message
    });
  }
}

/**
 * Execute an action on a webpage (via content script)
 */
async function handleExecuteAction(payload, sendResponse) {
  const { action, params, tabId } = payload;
  
  try {
    // Get active tab if tabId not provided
    let targetTabId = tabId;
    
    if (!targetTabId) {
      const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });
      targetTabId = activeTab.id;
    }
    
    // Send action to content script
    const response = await chrome.tabs.sendMessage(targetTabId, {
      type: 'EXECUTE_ACTION',
      action,
      params
    });
    
    sendResponse({
      success: true,
      data: response
    });
    
  } catch (error) {
    console.error('Error executing action:', error);
    sendResponse({
      success: false,
      error: error.message
    });
  }
}

/**
 * Save user settings to storage
 */
async function handleSaveSettings(payload, sendResponse) {
  try {
    await chrome.storage.local.set({ settings: payload });
    
    sendResponse({
      success: true,
      message: 'Settings saved successfully'
    });
    
  } catch (error) {
    console.error('Error saving settings:', error);
    sendResponse({
      success: false,
      error: error.message
    });
  }
}

// ============================================
// COMMAND EXECUTION (Phase 7)
// ============================================

/**
 * Execute browser automation commands
 */
async function handleExecuteCommand(payload, sendResponse) {
  const { command } = payload;
  const lowerCommand = command.toLowerCase();
  
  try {
    // Get active tab
    const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });
    
    if (!activeTab) {
      throw new Error('No active tab found');
    }
    
    // Parse and execute commands
    if (lowerCommand.includes('scroll down') || lowerCommand === 'scroll') {
      await executeScroll(activeTab.id, 'down');
      sendResponse({ success: true, message: 'Scrolled down' });
      
    } else if (lowerCommand.includes('scroll up')) {
      await executeScroll(activeTab.id, 'up');
      sendResponse({ success: true, message: 'Scrolled up' });
      
    } else if (lowerCommand.includes('open new tab') || lowerCommand.includes('new tab')) {
      const url = extractUrl(lowerCommand) || 'https://www.google.com';
      await chrome.tabs.create({ url });
      sendResponse({ success: true, message: `Opened new tab: ${url}` });
      
    } else if (lowerCommand.includes('close tab') || lowerCommand.includes('close this')) {
      await chrome.tabs.remove(activeTab.id);
      sendResponse({ success: true, message: 'Tab closed' });
      
    } else if (lowerCommand.includes('go to ') || lowerCommand.includes('open ') || lowerCommand.includes('navigate to ')) {
      const url = extractUrl(lowerCommand);
      if (url) {
        await chrome.tabs.update(activeTab.id, { url });
        sendResponse({ success: true, message: `Navigating to ${url}` });
      } else {
        throw new Error('Could not extract URL from command');
      }
      
    } else if (lowerCommand.includes('contact') || lowerCommand.includes('email') || lowerCommand.includes('phone')) {
      const contacts = await extractContacts(activeTab.id);
      sendResponse({ 
        success: true, 
        message: `Found contacts:\n${contacts.emails.join(', ')}\n${contacts.phones.join(', ')}`,
        data: contacts
      });
      
    } else if (lowerCommand.includes('back')) {
      await chrome.tabs.goBack(activeTab.id);
      sendResponse({ success: true, message: 'Navigated back' });
      
    } else if (lowerCommand.includes('forward')) {
      await chrome.tabs.goForward(activeTab.id);
      sendResponse({ success: true, message: 'Navigated forward' });
      
    } else if (lowerCommand.includes('refresh') || lowerCommand.includes('reload')) {
      await chrome.tabs.reload(activeTab.id);
      sendResponse({ success: true, message: 'Page refreshed' });
      
    } else {
      throw new Error('Command not recognized. Try: scroll, open tab, close tab, go to [url], fetch contacts');
    }
    
  } catch (error) {
    console.error('Command execution error:', error);
    sendResponse({
      success: false,
      error: error.message || 'Failed to execute command'
    });
  }
}

/**
 * Execute scroll command on page
 */
async function executeScroll(tabId, direction) {
  const scrollAmount = direction === 'down' ? 400 : -400;
  
  await chrome.scripting.executeScript({
    target: { tabId },
    func: (amount) => {
      window.scrollBy({ top: amount, behavior: 'smooth' });
    },
    args: [scrollAmount]
  });
}

/**
 * Extract URL from command text
 */
function extractUrl(command) {
  // Check for explicit URL
  const urlMatch = command.match(/(?:https?:\/\/)?(?:www\.)?([a-zA-Z0-9-]+\.[a-zA-Z]{2,}(?:\/[^\s]*)?)/);
  if (urlMatch) {
    let url = urlMatch[0];
    if (!url.startsWith('http')) {
      url = 'https://' + url;
    }
    return url;
  }
  
  // Extract site name and construct URL
  const siteMatch = command.match(/(?:go to|open|navigate to)\s+([a-zA-Z0-9]+)/i);
  if (siteMatch) {
    const site = siteMatch[1];
    return `https://www.${site}.com`;
  }
  
  return null;
}

/**
 * Extract contact information from page
 */
async function extractContacts(tabId) {
  const results = await chrome.scripting.executeScript({
    target: { tabId },
    func: () => {
      const text = document.body.innerText;
      
      // Extract emails
      const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
      const emails = [...new Set(text.match(emailRegex) || [])];
      
      // Extract phone numbers
      const phoneRegex = /(?:\+\d{1,3}[-.\s]?)?(?:\(?\d{1,4}\)?[-.\s]?)?\d{1,4}[-.\s]?\d{1,4}[-.\s]?\d{1,9}/g;
      const phones = [...new Set(text.match(phoneRegex) || [])]
        .filter(p => p.replace(/\D/g, '').length >= 10)
        .slice(0, 5);
      
      return { emails, phones };
    }
  });
  
  return results[0]?.result || { emails: [], phones: [] };
}

console.log('VynceAI Background Service Worker loaded');
